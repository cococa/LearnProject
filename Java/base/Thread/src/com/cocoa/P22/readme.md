#  synchronized  同步语句块


###  synchronized 修饰方法的时候,会存在很多弊端, 个人认为,在修饰方式的时候, 扩大了同步的区域, 在一个线程执行同步方法时
另一线程只能等待,而且无法执行该方法中的任何语句, 而 同步语句块则可以解决这个问题, 可以将需要进行同步的语句用同步语句块修饰
然后,方法中的除同步语句块外的代码,都是不被阻塞的(注意,是在同步语句块之上的代码)

###  synchronized(this) 锁定的当前对象, 在226章节可以得知


### 227 章节中, 使用了任意对象, 即 synchronized(非this对象) , 锁非this 对象有它的优点, 如果在同一类中,有很多同步方法,
这时虽然都能实现同步, 但是会受到阻塞, 所以影响效率, 但是如果使用所非this 对象, 则synchronized(非this对象) 代码块中的程序与同步方法是异步的,
不与其实锁this 同步方法争抢this 锁 ,则可以大大提高效率  (这里理解起来有点困难,看代码)

###  在锁非 this 对象时,  对象监视器必须是统一对象, 如果不是同一对象, 则就是异步调用, 和没锁是一样的

###  229 章节中, synchronized 可以修饰 static 方法, 该操作是对class 对象进行加锁  , 而synchronized 修饰 非static 方法 ,则是对改对象进行上锁, 这一点的理解其实不难,就是对static 的理解, 这里的例子还没写, 以后补上



###  2210 章节中 , 主要说明了 string 常量池的问题 , 所以大部数情况下, 都不使用 string 作为锁对象


### 2211 章节中, 主要介绍了使用synchroized 锁方法造成的死锁 ,然后使用 同步代码块解决了问题
